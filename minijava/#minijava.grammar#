Helpers
  letter = [['a' .. 'z'] + ['A' .. 'Z']];
  digit = ['0' .. '9'];

Tokens 
    classn = 'class';
    extends = 'extends';
    public = 'public';
    static = 'static';
    void = 'void';
    main = 'main';
    string = 'String';
    int = 'int';
    boolean = 'boolean';
    if = 'if';
    else = 'else';
    while = 'while';
    length = 'length' ;
    new = 'new';
    true = 'true';
    false = 'false';
    return = 'return';
    this = 'this';
    
    id = letter (letter | digit | '_')*;
    number = digit (digit)*;
    
    plusminusop = '+' | '-';
    timesop = '*';
    and = '&&';
    less = '<';
    
    equal = '=';
    not = '!';
    l_bracket = '[';
    r_bracket = ']';
    l_brace = '{';
    r_brace = '}';
    l_parenthese = '(';
    r_parenthese = ')';
    dot = '.';
    semicolon = ';';
    comma = ',' ;
    
    blank = (' ' | 10 | 13 | 9)*;

    print = 'System.out.println';

Productions

program = 
     mainclass classdecl*;

mainclass = 
     classn [classname]:id l_brace mainmethod r_brace;

mainmethod =
     public static void main l_parenthese string l_bracket r_bracket [paramname]:id r_parenthese l_brace statement r_brace;

classdecl = 
     {simpleclass} classn [classname]:id 
                   l_brace 
                       [vars]:vardecl* 
                       [methods]:methoddecl*
                   r_brace
   | {extendingclass} classn [classname]:id extends [super]:id 
                      l_brace
                          [vars]:vardecl* 
                          [methods]:methoddecl*
		      r_brace;
 
vardecl = 
    type [varname]:id semicolon;

methoddecl =
    public type [methodname]:id l_parenthese paramlist r_parenthese 
        l_brace
	     [vars]:vardecl* 
	     [statements]:statement* 
	     return [returnexpression]:exp semicolon 
        r_brace;

paramlist = 
    {firstparameter} type id paramrest* |
    {empty} blank;

paramrest =
    {anotherparameter} comma type id;

type =
    {intvector} int l_bracket r_bracket |
    {boolean} boolean |
    {int} int |
    {id} id ;

statement =
    {statements} l_brace statement* r_brace |
    {ifelse} if l_parenthese exp r_parenthese [ifstatement]:statement else [elsestatement]:statement |
    {while} while l_parenthese exp r_parenthese statement |
    {print} print l_parenthese exp r_parenthese semicolon |
    {attr} id equal exp semicolon |
    {arrayattr} id l_bracket [arrayindex]:exp r_bracket equal [righthandside]:exp semicolon;

exp = andstm_list;

andstm_list =
    less_than andstm_rest*;

andstm_rest =
    and less_than;

less_than = 
    plus_minus_list less_than_plus_minus? ;

less_than_plus_minus = 
    less plus_minus_list;

plus_minus_list = times_list plus_minus_rest* ;

plus_minus_rest = 
    plusminusop times_list;

times_list =
    prefixexp times_rest* ; 

times_rest =
    timesop prefixexp;

prefixexp =
      {not_expression} notexp 
    | {expression} postfixexp_list;

notexp = 
    not+ postfixexp_list;

postfixexp_list = 
    primary_exp postfixexp_rest*;

postfixexp_rest = 
      {index} l_bracket exp r_bracket
    | {idlist} exp dot id l_parenthese explist r_parenthese
    | {length} exp dot length ;

primary_exp = 
      {number} number
    | {true} true
    | {false} false
    | {id} id
    | {this} this
    | {newint} new int l_bracket exp r_bracket
    | {newid} new id l_parenthese r_parenthese
    | {lparexprpar} l_parenthese exp r_parenthese ;

explist = 
    {explisthead} exp exprest* |
    {blank} blank;

exprest = 
    comma exp;